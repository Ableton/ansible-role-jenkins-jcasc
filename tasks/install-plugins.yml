---
- name: Copy plugins file
  ansible.builtin.template:
    src: "{{ jenkins_plugins_file }}"
    dest: "{{ jenkins_config_dir }}/plugins.yaml"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_group }}"
    mode: "0644"
  diff: "{{ jenkins_show_plugins_yaml_changes }}"
  register: copy_plugins_yaml_file

- name: Install plugins
  when: copy_plugins_yaml_file is changed  # noqa no-handler
  block:
    - name: Determine if PIMT output should be logged to a separate file
      ansible.builtin.set_fact:
        jenkins_pimt_log_output_to_file: true
      when: jenkins_pimt_logfile != ''

    # Remove the plugins directory before installing plugins to avoid potential problems
    # with conflicting dependencies, and also to correctly handle the case when plugins
    # are removed from the plugins.yaml file. PIMT has a `--clean-download-directory`
    # argument, but we can't use it because it'll fail to remove the directory.
    - name: Clean plugins directory
      ansible.builtin.file:
        path: "{{ jenkins_plugins_dir }}"
        state: absent

    - name: Use PIMT to install plugins
      become: true
      become_user: "{{ jenkins_user }}"
      ansible.builtin.command: >
        java -jar
        {{ jenkins_pimt_path }}
        --plugin-download-directory {{ jenkins_plugins_dir }}
        --plugin-file {{ jenkins_config_dir }}/plugins.yaml
        --war {{ jenkins_war }}
        --verbose
        {{ jenkins_pimt_args }}
      changed_when: true
      environment:
        CACHE_DIR: "{{ jenkins_caches_dir }}"
      no_log: "{{ jenkins_pimt_log_output_to_file }}"
      retries: "{{ jenkins_download_retries }}"
      delay: "{{ jenkins_download_delay }}"
      register: plugin_installation_result
      until: plugin_installation_result is succeeded

    - name: Write the PIMT logfile data to the desired filename
      delegate_to: localhost
      become: false
      ansible.builtin.copy:
        dest: "{{ jenkins_pimt_logfile }}"
        content: "{{ plugin_installation_result.stderr }}"
        mode: "0644"
        # We are writing to localhost, so atomic writes shouldn't be an issue.
        unsafe_writes: true
      when: jenkins_pimt_log_output_to_file
  rescue:
    # Because we only run PIMT when the template file changed, we can end up in a bad
    # situation if PIMT fails for other reasons (for instance, a network glitch). This
    # will leave the Jenkins controller in a partially deployed state, and when this role
    # is run again, we need to ensure that PIMT will also be re-run. To do so, we alter
    # the plugins.yaml file, which will ensure that the template task will change it.
    - name: Write failure comment to plugins.yaml file
      ansible.builtin.lineinfile:
        path: "{{ jenkins_config_dir }}/plugins.yaml"
        line: "# Added by Ansible: PIMT failed on last run!"
        insertbefore: BOF

    - name: Force the play to fail
      ansible.builtin.fail:
        msg: >
          Plugin Installation Manager Tool failed with code
          {{ plugin_installation_result.rc }}: {{ plugin_installation_result.msg }}

# We install custom plugins AFTER installing everything else with the plugin installation
# manager tool. This allows us to ensure that these plugins are not overridden by a
# different and possibly conflicting version.
- name: Install custom Jenkins plugins
  ansible.builtin.copy:
    src: "{{ plugin_file }}"
    dest: "{{ jenkins_plugins_dir }}"
    owner: "{{ jenkins_user }}"
    group: "{{ jenkins_group }}"
    mode: "0644"
  with_items: "{{ jenkins_custom_plugins }}"
  loop_control:
    loop_var: plugin_file
